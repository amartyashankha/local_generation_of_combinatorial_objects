\section{Overview of our Techniques}
\label{sec:overview_of_our_techniques}
\subsection{Local-Access Implementations}
We begin by formalizing the model of \emph{local-access implementations} \textcolor{Maroon}{(trutuful implementation from \cite{huge}?)}.
Our work provides local-access implementations for various random objects described below.

\begin{definition}
\label{def:local_access}
Given a distribution $X$ over a set of huge random objects $\mathbb X$, a \emph{local access implementation}
of a family of query functions $\langle F_1, F_2,\cdots \rangle$ where $F_i: \mathbb X\rightarrow \{0,1\}$,
provides an oracle that returns the value $F_i(X)$ for $X\thicksim \mathbb X$ and a given query $F_i$, while satisfying the following:
%For clarity, we assume that the generator is invoked until its entire graph $G$ is exposed.
%The local-access generator for a probability distribution $\mathsf{D}$ of the desired random graph model must satisfy the following properties:
\begin{itemize}
    \item \textbf{Consistency:}
    All the values $F_i(X)$ returned by the local-access implementation throughout the entire execution
    must be consistent with a single $X\in \mathbb X$.
    \item \textbf{Distribution equivalence:}
    The random object $X\in \mathbb X$ consistent with the responses $\{ F_i(X)\}$ must be sampled from some distribution $\mathsf{X}'$
    that is $\epsilon$-close to the desired distribution $\mathsf{X}$ in $L_1$-distance.
    In this work we focus on supporting $\epsilon = n^{-c}$ for any desired constant $c>0$.
    \item \textbf{Performance:}
    The computation time, additional random bits, and additional space required to answer a single query must be sub-linear,
    and preferably $\poly(\log n)$ with high probability.
\end{itemize}
\end{definition}
In particular, we allow queries to be made adversarially and non-deterministically.
The adversary has full knowledge of the algorithm's behavior and its past random bits.




\subsection{Basic Tools for Efficient Sampling}
\todo[inline]{This section is incomplete.}
\label{sec:basic_tools_for_efficient_sampling}
\begin{lemma}
\label{lem:rejection_sampling}
Let $\{p_i\}$ and $\{q_i\}$ be distributions satisfying the following conditions
\begin{enumerate}
    \item There is a poly-time algorithm to approximate $p_i$ and $q_i$ up to $\pm n^{-2}$
    \item Generating an index $i$ according to $q_i$ is closely implementable.
    \item There exists a $poly(log n)$-time recognizable set $B$ such that
    \begin{itemize}
        \item $1-\sum\limits_{i\in B} p_i$ is negligible
        \item There exists a constant $c$ such that for every $i$, it holds that $p_i\le \log^{\mathcal{O}(1)} n\cdot q_i$
    \end{itemize}
\end{enumerate}
Then, generating an index $i$ according to the distribution $\{p_i\}$ is closely-implementable.
\end{lemma}

\paragraph*{CDF Based Sampling}
\label{par:cdf_based_sampling}

Consider a probability distribution $\mathsf{X}$ over $O(n)$ consecutive integers,
whose cumulative distribution function (CDF) for can be computed with at most $n^{-c}$ additive error for constant $c$.
Using $\Bo(\log n)$ CDF evaluations, one can sample from a distribution that is $\frac{1}{\poly(n)}$-close to $\mathsf{X}$ in $L_1$-distance.
\footnote{Generate a random $N$-bit number $r$, and binary-search for the smallest domain element $x$ where $\mathbb P[X\leq x] \geq r$.}




\input{overview/graphs}
\input{overview/catalan_overview}
\input{overview/coloring_overview}
