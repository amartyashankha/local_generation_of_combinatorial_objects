\section{Random Coloring of a Graph}%
\label{sec:random_coloring_of_a_graph}
A $q$-coloring of a graph $G=(V, E)$ is a function $\vec X : V\rightarrow [q]$, such that for all $(u,v)\in E$, $\vec X_u \not= \vec X_v$.
We will locally sample an uniformly random $q$-coloring of a graph, by implementing an oracle $\func{Color}(v)$,
which returns the color $\vec X_v$ of node $v$, where $\vec X$ is a uniformly random valid coloring.
Moreover, in this setting, multiple independent instances of $\func{Color}$ using the same random bits,
should output color values consistent with a single $\vec X$, regardless of the order and content of the queries received.
We consider graphs with max degree $\Delta$ and $q = \Theta(\Delta)$, since this is the regime where this problem is feasible \cite{glauber_survey}.

Using the technique of path-coupling, \cite{glauber_survey} showed that for $q > 2\Delta$,
one can sample an uniformly random coloring by using a simple Markov chain.
The Markov chain proceeds in $T$ steps. The state of the chain at time $t$ is given by $\vec X^t\in [q]^{|V|}$.
Specifically, the color of vertex $v$ at step $t$ is $\vec X^t_v$.
In each step of the Markov process, a pair $(v, c)\in V\times [q]$ is sampled uniformly at random.
Subsequently, if the recoloring of vertex $v$ with color $c$ does not result in a conflict with $v$'s neighbors,
i.e. $c\not\in \left\{ \vec X^t_u : u\in \Gamma(v)\right\}$, then the vertex is recolored i.e. $\vec X_v^{t+1}\leftarrow c$.
After running this chain for $T = \mathcal{O}(n\log n)$ steps, the Markov chain is mixed,
i.e. the distribution of resulting colors is close to the uniform distribution in $L_1$ distance.



\subsection{Modified Glauber Dynamics}%
\label{sec:modified_glauber_dynamics}

Now we define a modified Markov chain as a special case of the \emph{Local Glauber Dynamics} presented in \cite{mohsen}.
The modified Markov chain proceeds in epochs.
We denote the initial coloring of the graph by $\vec X^0$ and the state of the coloring after the $k^{th}$ epoch by $\vec X^k$.
In the $k^{th}$ epoch $\mathcal E_k$:
\begin{itemize}
    \item Sample $|V|$ colors $ \langle c_1, c_2,\cdots, c_n \rangle$ from $[q]$, where $c_v$ is the proposed color for vertex $v$.
    \item For each vertex $v$, we set $\vec X^k_v$ to $c_v$ if for all neighbors $w$ of $v$, $\vec X^k_w\not=c_v$ and $\vec X^{k-1}_w\not=c_v$.
\end{itemize}
%\begin{itemize}
    %\item Pick a random permutation $\pi^{(i)}$ of the vertices $V$.
    %\item Sample $n = |V|$ colors $ \langle c_1, c_2,\cdots, c_n \rangle$ from $[q]$.
    %\item Perform the standard update using the pairs $\left\langle (\pi^{(i)}_1, c_1), (\pi^{(i)}_2, c_2), \cdots, (\pi^{(i)}_n, c_n)\right\rangle$.
%\end{itemize}

This procedure is a special case of the \emph{Local Glauber Dynamics} presented in \cite{mohsen}.
We can directly use their path coupling argument, which we briefly describe below.
Given two colorings $\vec X$ and $\vec Y$, we define $d(\vec X,\vec Y)$ as the number of vertices $v$ such that $\vec X_v\not= \vec Y_v$.
We define the coupling $(\vec X,\vec Y)\rightarrow(\vec X',\vec Y')$ where $\vec X$ and $\vec Y$
differ only at a single vertex $v$ such that $\vec X_v = c_X$ and $\vec Y_v = c_Y$.
Now, we pick a random permutation of the vertices along with uniformly sampled colors:
\[
\left\langle (v_1, c_1), (v_2, c_2), \cdots, (v_n, c_n)\right\rangle
= \left\langle (\pi_1, c_1), (\pi_2, c_2), \cdots, (\pi_n, c_n)\right\rangle
\]
Now, for each $(v_i, c_i)$ in order, we update the coloring of $X$ and $Y$ as follows:
\begin{itemize}
    \item If the current color of $v_i$ as well as $c_i$ are both in $\{c_X,c_Y\}$,
    then the $\vec X$ chain picks the color $c_i$ and the $\vec Y$ chain picks the other color.
    \item Otherwise, both chains pick the same color $c_i$ for the vertex $v_i$.
\end{itemize}
We use the following result from \cite{mohsen} that bounds the coupled distance.
\begin{lemma}
\label{lem:mohsen_single_epoch_distance}
If $q = 2\alpha\Delta$ and $d(\vec X, \vec Y) = 1$,
then $\mathbb E[d(\vec X',\vec Y')] \le 1-\left( 1-\frac1{2\alpha}\right)e^{-3/\alpha} + \frac{1/2\alpha}{1-1/\alpha}$
\end{lemma}
\begin{corollary}
\label{cor:single_epoch_distansce}
If $q \ge 9\Delta$ and $d(\vec X, \vec Y) = 1$, then $\mathbb E[d(\vec X',\vec Y')] < \frac1{e^{1/3}}$
\end{corollary}

\begin{theorem}
\label{thm:modified_mixing_time}
If $q\ge 9\Delta$, then the chain is mixed after $\tau_{mix}(\epsilon) = 3\left( \ln n + \ln(\frac1{\epsilon})\right)$ epochs.
\end{theorem}
\begin{proof}
Starting for a maximum distance of $n$, the distance decreases to $1$ after at most $3\ln n$ epochs,
and it takes a further $3\ln\left( \frac{1}{\epsilon} \right)$ to reduce the distance to $\epsilon$.
\end{proof}




\subsection{Local Coloring Algorithm}%
\label{sec:local_coloring_algortihm}
Given query access to the adjacency matrix of a graph $G$ with maximum degree $\Delta$ and a vertex $v$,
the algorithm has to output the color of $v$ after running $t = \mathcal O(\ln n)$ epochs of \emph{Modified Glauber Dynamics}.
We will define the number of colors as $q = 2\alpha\Delta$ where $\alpha > 1$.

The proposals at each epoch are a vector of color samples $\vec C^{t} \thicksim_{\mathcal U} [q]^n$,
where $\vec C^t_v$ is the color proposed by $v$ in the $t^{th}$ epoch.
Note that these values are fully independent and as such any $\vec C^t_v$ can be sampled trivially.
We also use $\vec X^t$ to denote the final vector of vertex colors at the end of the $t^{th}$ epoch.
Finally, we define indicator variables $\bm \chi^t_v$ to denote if the color $\vec C^t_v$ proposed by vertex $v$ was accepted at the $t^{th}$ epoch;
$\bm \chi^t_v = \ONE$ if and only if for all neighbors $w\in \Gamma(v)$,
we satisfy the condition $\vec C^t_v\not= \vec X^{t-1}_w$ and $\vec C^t_v\not= \vec C^t_w$.
So, the color of a vertex $v$ after the $t^{th}$ epoch $\vec X^t_v$ is set to be $\vec C^i_v$
where $i\le t$ is the largest index such that $\bm \chi^i_v=1$.
While the proposals $\vec C^t_v$ are easy to sample, it is much less clear how we can sample the $\bm \chi^t_v$ values.
Note that we can compute $\vec X^t_v$ quite easily if we know the values $\bm\chi^i_v$ for all $i\le t$.
So, we focus our attention on the query $\func{Accepted}(v,t)$ that returns $\bm\chi^t_v$.


\subsubsection{Naive Coloring Implementations}%
\label{sec:naive_coloring_implementations}
A general strategy to sample $\bm\chi^t_v$ is to check for all neighbors $w$ of $v$,
whether $w$ conflicts with $v$'s proposed color in the $t^{th}$ epoch.
One naive way to achieve this, is to iterate backwards from epoch $t$, querying to find out whether $w$'s proposal was accepted,
until the first accepted proposal (latest epoch $t' < t$ such that $\bm\chi^{t'}_w=\ONE$) is found.
At this point, if $\vec C^{t'}_w =\vec C^t_v$, then the current color of $w$ conflicts with $v$'s proposal.
Otherwise there is no conflict, and we can proceed to the next neighbor.
However, this process potentially makes $\Delta$ recursive calls to a sub-problem that is only slightly smaller i.e. $T(t) \le \Delta\cdot T(t-1)$.
This leads to a running time upper bound of $\Delta^{t}$ which is superlinear for the desired mixing time $t = \Omega(\log n)$.

We can prune the number of recursive calls by only processing the neighbors $w$ which actually proposed the color $\vec C^t_v$ during \emph{some} epoch.
In this case, the expected number of neighbors that have to be probed recursively is $\le t\Delta/q$
(since the total number of neighbor proposals over $t$ epochs is at most $t\Delta$).
So, the overall runtime is upper bounded by $(t\Delta/q)^{t}$.
For this algorithm, if we allow $q > t\Delta = \Omega(\Delta\log n)$ colors, the runtime becomes sublinear.
This lower bound on $q$ is however asymptotically worse that the sequential requirement $q > 2\Delta = \mathcal O(\Delta)$.


\subsubsection{Jumping Back to Past Epochs}
\label{sec:jumping_back_to_past_epochs}
\begin{wrapfigure}[18]{r}{0.48\textwidth}
\vspace{-3.0em}
\begin{framed}
    \renewcommand\figurename{Algorithm}
    \caption{Checking if proposal is accepted}
    \label{alg:coloring}
    \begin{algorithmic}[1]
        \Procedure{Accepted}{$v, t$}
            \State {$c\gets\vec C^t_v$}
            \For{$w \gets \Gamma(v)$}
                \If {$\vec C_w^t = c$}
                    \State \Return $\ZERO$
                \EndIf
                \For{$t' \gets [t, t-1, t-2, \cdots, 1]$}
                    \If {$\mathcal\vec C^{t'}_w = c$ \textbf{and} \func{Accepted}($w, t'$)}
                        \State $flag\gets \ONE$
                        \While{$t' < t-1$}
                            \State $t'\gets t' + 1$
                            \If {\func{Accepted}($w, t'$)}
                                \State $flag\gets \ZERO$
                                \State \textbf{break}
                            \EndIf
                        \EndWhile
                        \If {$flag = \ONE$}
                            \State \Return $\ZERO$
                        \EndIf
                        \State \textbf{break}
                   \EndIf
                \EndFor
            \EndFor
            \State \Return $\ONE$
        \EndProcedure
    \end{algorithmic}
\end{framed}
\end{wrapfigure}
The expected number of neighbors that need to be checked can always be $t\Delta$ in the worst case.
The crucial observation is that even though these recursive calls seem unavoidable,
we can aim to reduce the size of the recursive sub-problem and thus bound the number of levels of recursion.
Because of the more complex structure of this epoch jumping process, the main challenge is to analyze the runtime.

Algorithm~\ref{alg:coloring} shows our final procedure for sampling $\bm\chi^t_v$ where $c =\vec C^t_v$ is the color proposed by $v$ in epoch $t$.
We iterate through all neighbors $w$ of $v$, checking for conflicts.
The condition $c\not=\vec C^t_w$ is can easily be checked by sampling $\vec C^t_w$.
If no conflict is seen, the next step is to check whether $c\not= \vec X^{t-1}_w$.

To achieve this, we iterate through all the epochs in reverse order (without making recursive calls)
to check whether the color $c$ was ever proposed for vertex $w$.
If not, we can ignore $w$, and otherwise let's say that the last proposal for $c$ was at epoch $t'$ i.e. $\vec C^{t'}_w = c$.
Now, we directly ``jump'' to the $t'^{th}$ epoch and recursively check if this proposal was accepted.
If the proposal $\vec C^{t'}_w$ was not accepted, we keep iterating back until we find another epoch when $c$ was proposed $w$, or we run out of epochs.
Otherwise if $c$ was accepted i.e. $\bm\chi^{t'}_w = \ONE$,
we successively consider epochs $t'+1, t'+2, t'+3, \cdots, t-1$ to see whether the color $c$ was replaced by an accepted proposal in a future epoch,
by recursively invoking $\func{Accepted}(w,t'+i)$ in order to sample $\bm\chi^{t'+i}_w$.
At this point we have seen that $\bm\chi^{t'}_w = \ONE$ (color $c$ was accepted) and every subsequent proposal until the current epoch was rejected,
implying that color $c$ \emph{survived}, i.e. $\vec X^{t-1}_w = c$.
This leads to a conflict with $v$'s current proposal for color $c$ and hence $\bm\chi^t_v = \ZERO$.
If at any of the iterations, we see that a different proposal was accepted, then $w$ does not cause a conflict and we can move on to the next neighbor.
If we exhaust all the neighbors and don't find any conflicts then $\bm\chi^t_v = \ONE$.

Now we analyze the runtime of $\func{Accepted}$ by constructing and solving a recurrence relation.
We will use the following lemma to evaluate the expectation of products of relevant random variables.

\begin{lemma}
\label{lem:color_reject_probability}
The probability that any given proposal is rejected $\mathbb P[\bm\chi^t_v=\ZERO]$ is at most $1/\alpha$.
Moreover, this upper bound holds even if we condition on all the values in $\vec C$ except $\vec C^t_v$.
\end{lemma}
\begin{proof}
A rejection can occur due to a conflict with at most $2\Delta$ possible values in $\{\vec C^t_w, X^{t-1}_w | w\in\Gamma(v)\}$.
Since there are $2\alpha\Delta$ colors, the rejection probability is at most $1/\alpha$.
\end{proof}

\begin{definition}
\label{def:coloring_recursions}
We define $T_t$ to be a random variable indicating the number of recursive calls performed during the execution of $\func{Accepted}(v,t)$
while sampling a single $\bm \chi_v^t$.
\end{definition}
So, the number of probes required to check whether a color $c$ (assigned at epoch $t'$) was overwritten at some epoch before $t$ is:
\begin{align}
\label{eq:color_overwrite}
\Biggl[T_{t'+1} + \mathcal B\left(\frac{1}{\alpha}\right)\cdot T_{t'+2}
+ \mathcal B\left(\frac{1}{\alpha^2}\right)\cdot T_{t'+3} + \cdots
+ \mathcal B\left(\frac{1}{\alpha^{t-t'-2}}\right)\cdot T_{t-1} \Biggr]
\end{align}

\begin{lemma}
\label{lem:coloring_recurrence}
Given graph $G$ and $q=2\alpha\Delta$ colors, for $\alpha > 4.5$, the expected number of recursive calls to the procedure $\func{Accepted}$
while sampling a single $\bm\chi^t_v = \func{Accepted}(v,t)$ is $\mathbb E[T_t] = \mathcal{O}\left(e^{1.02t/\alpha}\right)$.
\end{lemma}
\begin{proof}
We start with the recurrence for the expected number of probes to $\{\bm\chi^{t'}\}_{t'\in[t]}$
(equivalently calls to $\func{Accepted}$) used by the algorithm.
We will use $\mathcal B(p)$ to refer to the Bernoulli random variable with bias $p$.
When checking a single neighbor $w$, the algorithm iterates through all the epochs $t'$ such that $\vec C^{t'}_w = c$
(in reality, only the last occurence matters, but we are looking for an upper bound).
If such a $t'$ is found (this happens with probability $1/q$ independently for each trial), there is one recursive call to $T_{t'}$.
Regardless of what happens, let's say the algorithm queries $T_{t'+1}, T_{t'+2}, \cdots, T_{t-1}$ until an $\func{Accepted}$ proposal is found.
Adding an extra $T_{t'}$ term to Equation~\ref{eq:color_overwrite} and summing up over all neighbors and epochs we get the following:
\begin{align}
T_{t} &\le \Delta \cdot \mathlarger\sum\limits_{t'=1}^{t} \mathbb P[C^{t'}_w = c]\cdot
\Biggl[ T_{t'} + T_{t'+1} + \mathcal B\left(\frac{1}{\alpha}\right)\cdot T_{t'+2}
+ \mathcal B\left(\frac{1}{\alpha^2}\right)\cdot T_{t'+3} + \cdots\\
&\hspace{23em}
\cdots + \mathcal B\left(\frac{1}{\alpha^{t-t'-2}}\right)\cdot T_{t-1} \Biggr]\\
&\le \Delta\cdot\mathcal B\left( \frac{1}{q}\right) \Biggl[
\mathlarger\sum\limits_{t'=1}^{t-1} T_{t'} +
\mathlarger\sum\limits_{t'=1}^{t-1} T_{t'}\cdot \left(1 + \mathcal B\left(\frac1\alpha\right) + \mathcal B\left(\frac1{\alpha^2}\right) + \cdots\right)
\Biggr]
\end{align}
In the second step, we just group all the terms from the same epoch together.
Using Lemma~\ref{lem:color_reject_probability} and the fact that $\mathbb P[C^{t'}_w = c]$ is independent of all other events,
we can write a recurrence for the expected number of probes.
\begin{align}
\mathbb E[T_t] \le \Delta\cdot\frac{1}{2\alpha\Delta}
\left[
\mathlarger\sum\limits_{t'=1}^{t-1} T_{t'} + \mathlarger\sum\limits_{t'=1}^{t-1} T_{t'}\cdot \left(1 + \frac1\alpha + \frac1{\alpha^2} + \cdots\right)
\right]
\le \frac{1}{2\alpha}\cdot \mathlarger\sum\limits_{t'=1}^{t-1} T_{t'}\cdot \left[1 + \frac{\alpha}{\alpha-1} \right]
\end{align}
Now, we make the assumption that $\mathbb E[T_{t'}]\le e^{k t/\alpha}$,
and show that this satisfies the expectation recurrence for the desired value of $k$.
First, we sum the geometric series:
\[
\mathlarger\sum\limits_{t'=1}^{t-1} \mathbb E[T_{t'}] = \mathlarger\sum\limits_{t'=1}^{t-1} e^{k t'/\alpha}
< \frac{e^{k t/\alpha}-1}{e^{k/\alpha}-1} < \frac{e^{k t/\alpha}}{e^{k/\alpha}-1}
\]
The expectation recurrence to be satisfied then becomes:
\[
\mathbb E[T_t]\le \frac 1{2\alpha}\cdot \frac{e^{k t/\alpha}}{e^{k/\alpha}-1}\cdot \left[ 1+ \frac{\alpha}{\alpha-1} \right]
= e^{k t/\alpha}\cdot \frac{2\alpha-1}{2\alpha(\alpha-1)(e^{k/\alpha}-1)} = e^{k t/\alpha}\cdot f(\alpha, k)
\]
We notice that for $k=1.02$ and $\alpha > 4.5$, $f(\alpha) < 1$.
This can easily be verified by checking that $f(\alpha,1.02)$ decreases monotonically with $\alpha$ in the range $\alpha > 4.5$.
Thus, our recurrence is satisfied for $k=1.02$, and therefore the expected number of calls is $\mathcal O(e^{1.02t/\alpha})$.
\end{proof}

%\begin{corollary}
%\label{cor:coloring_improved_probes}
%Instead of looking through all the epochs in order, we can use the coloring generator \todo{where?} to find the locations directly.
%\end{corollary}

\begin{theorem}
\label{thm:coloring_generator_main}
Given adjacency list query access to a graph with $n$ nodes, maximum degree $\Delta$, and $q=2\alpha\Delta \ge 9\Delta$ colors,
we can sample the color of any given node from a distribution of color assignments that is $\frac{1}{n}$-close (in $L_1$ distance)
to the uniform distribution over all colorings of the graph, in a consistent manner,
using only $\mathcal O(n^{6.12/\alpha}\Delta\log n)$ time and random bits.
%This is sublinear for $\alpha > 6.12$ and the sampled coloring is $1/n$-close to the uniform distribution in $L_1$ distance.
\end{theorem}
\begin{proof}
Since $q\ge 9\Delta$, we can use Theorem~\ref{thm:modified_mixing_time} to obtain $\tau_{mix}(1/n) \le 6\ln n$.
Since $\alpha > 4.5$, we can invoke Lemma~\ref{lem:coloring_recurrence} to conclude that
the number of calls to $\func{Accepted}$ is $\mathcal O(n^{6.12/\alpha})$.
Finally, we note that each call to \func{Accepted}$(v,t)$ potentially samples $\mathcal O(t\Delta)$ color proposals,
while iterating through all the neighbors of $v$ in all $t$ epochs.
Since $t \le 6\ln n$, this implies that the algorithm uses $\mathcal O(n^{6.12/\alpha}\Delta\log n)$ time and random bits,
which is sublinear for $\alpha > 6.12$.
\end{proof}
\todo[inline,color=Red!20]{theorem about parallel copies}
