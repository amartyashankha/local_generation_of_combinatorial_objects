\section{Random Coloring of a Graph}%
\label{sec:random_coloring_of_a_graph}
A \emph{valid} $q$-coloring of a graph $G=(V, E)$ is a vector of colors $\vec X \in [q]^V$, such that for all $(u,v)\in E$, $\vec X_u \not= \vec X_v$.
We present a sublinear time algorithm to provide local access to a uniformly random valid $q$-coloring of an input graph.
Specifically, we implement $\func{Color}(v)$, which returns the color $\vec X_v$ of node $v$, where $\vec X$ is a uniformly random valid coloring.
The implementation can access the input graph $G$ through a sub-linear number of \emph{neighborhood queries}.
A neighborhood query of the form $\func{All-Neighbors}(v)$ returns a list of neighbors of $v$.
The implementation can also access a tape of public random bits $\vec R$.

Moreover, multiple independent instances of $\func{Color}$ that are given access to the same public tape of random bits $\vec R$,
should output color values consistent with a single $\vec X$, regardless of the order and content of the queries received.
Unlike our previous results, the choice of $\vec X$ only depends on $\vec R$,
%\footnote{In the case of undirected graphs and Catalan objects, the final sample depend both on the randomness and the order and content of queries},
and the \func{Color} implementations do not need to use any additional memory to maintain consistency.
For a formal description of this model, see Definition~\ref{def:local_access_LCA}.
\textcolor{Maroon}{We consider graphs with max degree $\Delta$, and $q = \Theta(\Delta)$, since this is the regime where this problem is feasible \cite{glauber_survey}.}
\todo[inline,color=red!80!green!25]{Comparison to LCAs}

In the sequential setting, \cite{glauber_survey} used the technique of path coupling to show that for $q > 2\Delta$,
one can sample an uniformly random coloring by using a simple Markov chain.
The Markov chain proceeds in $T$ steps. The state of the chain at time $t$ is given by $\vec X^t\in [q]^{|V|}$.
Specifically, the color of vertex $v$ at step $t$ is $\vec X^t_v$.
In each step of the Markov process, a vertex and a color are sampled uniformly at random i.e. a pair $(v, c)\thicksim_{\mathcal U} V\times [q]$.
Subsequently, if the recoloring of vertex $v$ with color $c$ does not result in a conflict with $v$'s neighbors,
i.e. $c\not\in \left\{ \vec X^t_u : u\in \Gamma(v)\right\}$, then the vertex is recolored i.e. $\vec X_v^{t+1}\leftarrow c$.
After running this chain for $T = \mathcal{O}(n\log (n/\epsilon))$ steps, the Markov chain is mixed,
implying that the distribution of resulting colors is $\epsilon$ close to the uniform distribution in $L_1$ distance.
\todo[inline,color=red!80!green!25]{Use $q = 2\alpha\Delta$ everywhere.}



\subsection{Modified Glauber Dynamics based on a Distributed Algorithm}%
\label{sec:modified_glauber_dynamics}

Now we define a modified Markov chain as a special case of the \emph{Local Glauber Dynamics} presented in \cite{ghaffari_fischer}.
The modified Markov chain proceeds in epochs.
We denote the initial coloring of the graph by the vector $\vec X^0$ and the state of the coloring after the $k^{th}$ epoch by $\vec X^k$.
In the $k^{th}$ epoch, every node attempts to recolor itself simultaneously in a conservative manner, as described below:
\begin{itemize}
    \item Sample $|V|$ colors $ \langle c_1, c_2,\cdots, c_n \rangle$ from $[q]$, where $c_v$ is the color proposed by vertex $v$.
    \item For each vertex $v$, we set $\vec X^k_v$ to $c_v$, if and only if for all neighbors $w$ of $v$, $\vec X^{k-1}_w\not=c_v$ and $c_w\not=c_v$.
Specifically, a vertex $v$ is recolored if and only if its proposed color $c_v$
does not conflict with any of it's neighbors current colors (at the end of the previous epoch), or their current proposals.
\end{itemize}

This procedure is a special case of the \emph{Local Glauber Dynamics},
which was presented in \cite{ghaffari_fischer} as a distributed algorithm for sampling a random coloring.\footnote{
Note that \cite{ghaffari_fischer} also uses a marking probability $\gamma$,
which indicates the likelihood of any vertex participating in a given round.
For our purposes, it suffices to set $\gamma = 1$.}
In the distributed setting, our epochs correspond to synchronous rounds, where many vertices recolor themselves simultaneously.

In order to bound the mixing time of this Markov chain,
\cite{ghaffari_fischer} uses the standard technique of \emph{path coupling}, introduced in \cite{path_coupling}.
The argument begins by considering two initial states of the Markov Chains, say two colorings $\vec X^0$ and $\vec Y^0$,
that differ at only one vertex.
Formally, we can define the distance between two colorings $d(\vec X,\vec Y)$ as the number of vertices $v$ such that $\vec X_v\not= \vec Y_v$,
which results in the condition $d(\vec X^0, \vec Y^0) = 1$.
A \emph{coupling} is a joint evolution rule for a pair of states $(\vec X^0,\vec Y^0)\rightarrow(\vec X^1,\vec Y^1)$,
such that both of the individual evolutions $(\vec X^0\rightarrow \vec X^1)$ and $(\vec Y^0\rightarrow \vec Y^1)$
have the same transition probabilities as the original Markov Chain.
%Now, we pick a random permutation of the vertices along with uniformly sampled colors:
%\[
%\left\langle (v_1, c_1), (v_2, c_2), \cdots, (v_n, c_n)\right\rangle
%= \left\langle (\pi_1, c_1), (\pi_2, c_2), \cdots, (\pi_n, c_n)\right\rangle
%\]
%Now, for each $(v_i, c_i)$ in order, we update the coloring of $X$ and $Y$ as follows:
%\begin{itemize}
    %\item If the current color of $v_i$ as well as $c_i$ are both in $\{c_X,c_Y\}$,
    %then the $\vec X$ chain picks the color $c_i$ and the $\vec Y$ chain picks the other color.
    %\item Otherwise, both chains pick the same color $c_i$ for the vertex $v_i$.
%\end{itemize}
We can directly use the result from the coupling defined in \cite{ghaffari_fischer}.
\begin{lemma}
\label{lem:ghaffari_fischer_single_epoch_distance}
If $q = 2\alpha\Delta$, then there exists a coupling $(\vec X^0,\vec Y^0)\rightarrow(\vec X^1,\vec Y^1)$, such that if $d(\vec X^0, \vec Y^0) = 1$,
then $\mathbb E[d(\vec X^1,\vec Y^1)] \le 1-\left( 1-\frac1{2\alpha}\right)e^{-3/\alpha} + \frac{1/2\alpha}{1-1/\alpha}$
\end{lemma}
\begin{corollary}
\label{cor:single_epoch_distansce}
If $q \ge 9\Delta$ and $d(\vec X^0, \vec Y^0) = 1$, then $\mathbb E[d(\vec X^1,\vec Y^1)] < \frac1{e^{1/3}}$
\end{corollary}

The \emph{path coupling} lemma from \cite{path_coupling} uses a coupling on adjacent states to bound the mixing time.
\begin{lemma}
\label{lem:path_coupling}
\textbf{(Simplified Path Coupling from \cite{path_coupling})}
If there exists a coupling $(\vec X^0,\vec Y^0)\rightarrow(\vec X^1,\vec Y^1)$ defined for states where $d(\vec X^0, \vec Y^0) = 1$,
such that $\mathbb{E}[d(\vec X^1, \vec Y^1) \mid \vec X^0, \vec Y^0] \le \beta$ (for $\beta < 1$),
then, the mixing time $\tau_{mix}(\epsilon) = \mathcal O(\ln (n\epsilon^{-1})/\ln \beta^{-1})$.
\end{lemma}

\begin{corollary}
\label{cor:modified_mixing_time}
If $q\ge 9\Delta$, then the chain is mixed after $\tau_{mix}(\epsilon) = 3\left( \ln n + \ln(\frac1{\epsilon})\right)$ epochs.
\end{corollary}
%\begin{proof}
%Starting for a maximum distance of $n$, the distance decreases to $1$ after at most $3\ln n$ epochs,
%and it takes a further $3\ln\left( \frac{1}{\epsilon} \right)$ to reduce the distance to $\epsilon$.
%\end{proof}
\todo[inline,color=red!80!green!25]{Distributed Algo + Parnas-Ron \cite{parnas_ron} and how we do better.}
\todo[inline,color=red!80!green!25]{Similar to LCA for MIS}



\subsection{Local Coloring Algorithm}%
\label{sec:local_coloring_algortihm}
Given query access to the adjacency matrix of a graph $G$ with maximum degree $\Delta$ and a vertex $v$,
the algorithm has to output the color assigned to $v$ after running $t = \mathcal O(\ln n)$ epochs of \emph{Modified Glauber Dynamics}.
We want to be able to answer such queries in sublinear time, without simulating the entire Markov Chain.
We will define the number of colors as $q = 2\alpha\Delta$ where $\alpha > 1$.

The proposals at each epoch are a vector of color samples $\vec C^{t} \thicksim_{\mathcal U} [q]^n$,
where $\vec C^t_v$ is the color proposed by $v$ in the $t^{th}$ epoch.
Note that these values are fully independent and as such any $\vec C^t_v$ can be sampled trivially.
We also use $\vec X^t$ to denote the final vector of vertex colors at the end of the $t^{th}$ epoch.
Finally, we define indicator variables $\bm \chi^t_v$ to indicate whether the color $\vec C^t_v$ proposed by vertex $v$
was accepted at the $t^{th}$ epoch: $\bm \chi^t_v = \ONE$ if and only if for all neighbors $w\in \Gamma(v)$,
we satisfy the condition $\vec C^t_v\not= \vec X^{t-1}_w$ and $\vec C^t_v\not= \vec C^t_w$
(i.e. the proposed color does not conflict with any neighboring proposal or any neighbor's color from the preceding epoch).
So, the color of a vertex $v$ after the $t^{th}$ epoch $\vec X^t_v$ is set to be $\vec C^i_v$
where $i\le t$ is the largest index such that $\bm \chi^i_v=1$.
While the proposals $\vec C^t_v$ are easy \textcolor{Maroon}{to sample}, it is much less clear how we can determine the $\bm \chi^t_v$ values.
Note that we can compute $\vec X^t_v$ quite easily if we know the values $\bm\chi^i_v$ for all $i\le t$.
So, we focus our attention on the query $\func{Accepted}(v,t)$ that returns $\bm\chi^t_v$.


\subsubsection{Local Access to an Initial Valid Coloring}
\label{sec:local_access_to_an_initial_valid_coloring}
One caveat that we have not addressed is how we should initialize the Markov Chain.
The starting state can be any valid coloring of $G$.
One way to
\todo[inline,color=red!80!green!25]{How to initialize? \cite{coloring_initialize}}

\subsubsection{Naive Coloring Implementations}%
\label{sec:naive_coloring_implementations}
Our general strategy to determine $\bm\chi^t_v$ will be to check for all neighbors $w$ of $v$,
whether $w$ causes a conflict with $v$'s proposed color in the $t^{th}$ epoch.
One naive way to achieve this, is to iterate backwards from epoch $t$, querying to find out whether $w$'s proposal was accepted,
until the most recent accepted proposal (latest epoch $t' < t$ such that $\bm\chi^{t'}_w=\ONE$) is found.
At this point, if $\vec C^{t'}_w =\vec C^t_v$, then the current color of $w$ conflicts with $v$'s proposal.
Otherwise there is no conflict, and we can proceed to the next neighbor.
However, this process potentially makes $\Delta$ recursive calls to a sub-problem that is only slightly smaller i.e. $T(t) \le \Delta\cdot T(t-1)$.
This leads to a running time upper bound of $\Delta^{t}$ which is superlinear for the desired number of epochs $t = \Omega(\log n)$ (the mixing time).

We can prune the number of recursive calls by only processing the neighbors $w$ which actually proposed the color $\vec C^t_v$ during \emph{some} epoch.
In this case, the expected number of neighbors that have to be probed recursively is less than $t\Delta/q$
(since the total number of neighbor proposals over $t$ epochs is at most $t\Delta$, and there are $q$ possible colors).
So, the overall runtime is upper bounded by $(t\Delta/q)^{t}$.
For this algorithm, if we allow $q > t\Delta = \Omega(\Delta\log n)$ colors, the runtime becomes sublinear.
So, we can use this simple algorithm only when $q$ is sufficiently large.
However, we want a sub-linear time algorithm for $q = \mathcal O(\Delta)$.


\subsubsection{A Sublinear Time Algorithm for $q = \mathcal O(\Delta)$}
\label{sec:jumping_back_to_past_epochs}
The expected number of neighbors that need to be checked recursively can always be $t\Delta/q$ in the worst case.
The crucial observation is that even though these recursive calls seem unavoidable,
we can aim to reduce the size of the recursive sub-problem and thus bound the number of levels of recursion.
\textcolor{Maroon}{Because of the more complex structure of this epoch jumping process}, the main challenge is to analyze the runtime.

\todo[inline,color=red!80!green!25]{High Level algorithm.}
%\begin{wrapfigure}[19]{r}{0.58\textwidth}
%\vspace{-2.0em}
\begin{figure}[htpb]
\begin{framed}
    \renewcommand\figurename{Algorithm}
    \caption{Checking if proposal is accepted}
    \label{alg:coloring}
    \begin{algorithmic}[1]
        \Procedure{Accepted}{$v, t$}
            \State {$c\gets\vec C^t_v$} \Comment{\textcolor{Maroon}{Sample the color.}}
            \For{$w \gets \Gamma(v)$}
                \If {$\vec C_w^t = c$} \Comment{Check for conflict with neighbor's current proposal}
                    \State \Return $\ZERO$
                \EndIf
                \For{$t' \gets [t, t-1, t-2, \cdots, 1]$} \label{alg:line:iterate_backwards}
                    \If {$\mathcal\vec C^{t'}_w = c$ \textbf{and} \func{Accepted}($w, t'$)} \label{alg:line:check_accepted}
                        \Comment{Potential conflict with neighbor's color}
                        \State $overwritten\gets \FALSE$ \Comment{Check if color $c$ was overwritten by a future proposal}
                        \For{$\widetilde t \gets [t'+1, t'+2, \cdots, t-1]$} \label{alg:line:check_overwritten}
                            \If {\func{Accepted}($w, \widetilde t$)} \label{alg:line:check_overwritten_recursive}
                                \State $overwritten\gets \TRUE$
                                \State \textbf{break}
                            \EndIf
                        \EndFor
                        \If {\textbf{not} $overwritten$}
                        \State \Return $\ZERO$ \Comment{Conflict! This proposal is \textbf{not} accepted} \label{alg:line:conflict}
                        \EndIf
                        \State \textbf{break}
                   \EndIf
                \EndFor
            \EndFor
            \State \Return $\ONE$ \Comment{No conflicts! This proposal is accepted} \label{alg:line:no_conflict}
        \EndProcedure
    \end{algorithmic}
\end{framed}
\end{figure}
%\end{wrapfigure}
Algorithm~\ref{alg:coloring} shows our final procedure for sampling $\bm\chi^t_v$ where $c =\vec C^t_v$ is the color proposed by $v$ in epoch $t$.
We iterate through all neighbors $w$ of $v$, checking for conflicts.
The condition $c\not=\vec C^t_w$ is can easily be checked by sampling $\vec C^t_w$.
If no conflict is seen, the next step is to check whether $c\not= \vec X^{t-1}_w$.

To achieve this, we iterate through all the epochs in reverse order (line~\ref{alg:line:iterate_backwards})
to check whether the color $c$ was ever proposed for vertex $w$.
If not, we can ignore $w$, and otherwise let's say that the most recent proposal for $c$ was at epoch $t'$ i.e. $\vec C^{t'}_w = c$.
Now, we directly ``jump'' to the $(t')^{th}$ epoch and recursively check if this proposal was accepted (line~\ref{alg:line:check_accepted}).
If the proposal $\vec C^{t'}_w$ was not accepted, we keep iterating back in time until we find the next most recent epoch
when $c$ was proposed by $w$, or until we run out of epochs.
When we find the most recent epoch $t'$ in which $c$ was accepted i.e. $\bm\chi^{t'}_w = \ONE$,
we successively consider epochs $t'+1, t'+2, t'+3, \cdots, t-1$ to see whether the color $c$ was overwritten
(line~\ref{alg:line:check_overwritten}) by an accepted proposal in a future epoch.
This is done by recursively invoking $\func{Accepted}(w,t'+i)$ in order to compute $\bm\chi^{t'+i}_w$ (line~\ref{alg:line:check_overwritten_recursive}).
If at any of these subsequent iterations, we see that a different proposal was accepted (thus overwriting the color $c$),
then neighbor $w$ does not cause a conflict, and we can move on to the next neighbor.
Otherwise, we have seen that $\bm\chi^{t'}_w = \ONE$ (color $c$ was accepted) and every subsequent proposal until the current epoch $t$ was rejected,
implying that color $c$ \emph{survived} as the color of neighbor $w$, i.e. $\vec X^{t-1}_w = c$.
This leads to a conflict with $v$'s current proposal for color $c$ (line~\ref{alg:line:conflict}) and hence $\bm\chi^t_v = \ZERO$.
If we exhaust all the neighbors and don't find any conflicts (line~\ref{alg:line:no_conflict}) then $\bm\chi^t_v = \ONE$.

\todo[inline,color=red!80!green!25]{Picture?}

Now we analyze the runtime of $\func{Accepted}$ by constructing and solving a recurrence relation.
We will use the following lemma to evaluate the expectation of products of relevant random variables.

\begin{lemma}
\label{lem:color_reject_probability}
The probability that any given proposal is rejected $\mathbb P[\bm\chi^t_v=\ZERO]$ is at most $1/\alpha$.
Moreover, this upper bound holds even if we condition on all the values in $\vec C$ except $\vec C^t_v$.
\end{lemma}
\begin{proof}
A rejection can occur due to a conflict with at most $2\Delta$ possible values in $\{\vec C^t_w, X^{t-1}_w | w\in\Gamma(v)\}$.
Since there are $2\alpha\Delta$ colors, the rejection probability is at most $1/\alpha$.
\end{proof}

\begin{definition}
\label{def:coloring_recursions}
We define $T_t$ to be a random variable indicating the number of recursive calls performed during the execution of $\func{Accepted}(v,t)$
while computing a single $\bm \chi_v^t$.
\end{definition}

\begin{definition}
\label{def:blah}
We define $R^t_{t'}$ to be a random variable indicating the number of calls to \func{Accepted} that are required,
to check whether a color $c$ assigned at epoch $t'$ was overwritten at some epoch before $t$.
\end{definition}
Using $\mathcal B(p)$ to denote the Bernoulli random variable with bias $p$, we obtain an expression for $R^t_{t'}$.
\begin{align}
\label{eq:color_overwrite}
R^t_{t'} = \Biggl[T_{t'+1} + \mathcal B\left(\frac{1}{\alpha}\right)\cdot T_{t'+2}
+ \mathcal B\left(\frac{1}{\alpha^2}\right)\cdot T_{t'+3} + \cdots
+ \mathcal B\left(\frac{1}{\alpha^{t-t'-2}}\right)\cdot T_{t-1} \Biggr]
\end{align}
The aforementioned Equation~\ref{eq:color_overwrite} indicates that the call to $\func{Accepted}(v, t'+1)$
(line~\ref{alg:line:check_overwritten_recursive}) is always invoked (resulting in $T_{t'+1}$ invocations of \func{Accepted}).
However, the next call to $\func{Accepted}(v, t'+2)$ is invoked only if the previous one was not accepted,
which occurs with probability at most $1/\alpha$ (Lemma~\ref{lem:color_reject_probability}).
This gives us the $\mathcal B(1/\alpha)\cdot T_{t'+2}$ term in the expression.
In general, $\func{Accepted}(v, t'+i)$ is only invoked if the preceding $i-1$ calls to \func{Accepted} all returned $\ZERO$.
This event happens with probability at most $1/\alpha^{i-1}$.

\begin{lemma}
\label{lem:coloring_recurrence}
Given graph $G$ and $q=2\alpha\Delta$ colors, for $\alpha > 4.5$, the expected number of recursive calls to the procedure $\func{Accepted}$
while computing a single $\bm\chi^t_v = \func{Accepted}(v,t)$ is $\mathbb E[T_t] = \mathcal{O}\left(e^{1.02t/\alpha}\right)$.
\end{lemma}
\begin{proof}
We start with the recurrence for the expected number of probes to $\{\bm\chi^{t'}\}_{t'\in[t]}$
(equivalently calls to $\func{Accepted}$) used by the algorithm.
When checking a single neighbor $w$, the algorithm iterates through all the epochs $t'$ such that $\vec C^{t'}_w = c$
(in reality, only the last occurence matters, but we are looking for an upper bound).
If such a $t'$ is found (this happens with probability $1/q$ independently for each trial), there is one recursive call to $T_{t'}$.
Regardless of what happens, let's say the algorithm queries $T_{t'+1}, T_{t'+2}, \cdots, T_{t-1}$ until an $\func{Accepted}$ proposal is found.
Adding an extra $T_{t'}$ term to Equation~\ref{eq:color_overwrite} and summing up over all neighbors and epochs we get the following:
\begin{align}
T_{t} &\le \Delta \cdot \mathlarger\sum\limits_{t'=1}^{t} \mathbb P[C^{t'}_w = c]\cdot
\Biggl[ T_{t'} + T_{t'+1} + \mathcal B\left(\frac{1}{\alpha}\right)\cdot T_{t'+2}
+ \mathcal B\left(\frac{1}{\alpha^2}\right)\cdot T_{t'+3} + \cdots\\
&\hspace{23em}
\cdots + \mathcal B\left(\frac{1}{\alpha^{t-t'-2}}\right)\cdot T_{t-1} \Biggr]\\
&\le \Delta\cdot\mathcal B\left( \frac{1}{q}\right) \Biggl[
\mathlarger\sum\limits_{t'=1}^{t-1} T_{t'} +
\mathlarger\sum\limits_{t'=1}^{t-1} T_{t'}\cdot \left(1 + \mathcal B\left(\frac1\alpha\right) + \mathcal B\left(\frac1{\alpha^2}\right) + \cdots\right)
\Biggr]
\end{align}
In the second step, we just group all the terms from the same epoch together.
Using Lemma~\ref{lem:color_reject_probability} and the fact that $\mathbb P[C^{t'}_w = c]$ is independent of all other events,
we can write a recurrence for the expected number of probes.
\begin{align}
\mathbb E[T_t] \le \Delta\cdot\frac{1}{2\alpha\Delta}
\left[
\mathlarger\sum\limits_{t'=1}^{t-1} T_{t'} + \mathlarger\sum\limits_{t'=1}^{t-1} T_{t'}\cdot \left(1 + \frac1\alpha + \frac1{\alpha^2} + \cdots\right)
\right]
\le \frac{1}{2\alpha}\cdot \mathlarger\sum\limits_{t'=1}^{t-1} T_{t'}\cdot \left[1 + \frac{\alpha}{\alpha-1} \right]
\end{align}
Now, we make the assumption that $\mathbb E[T_{t'}]\le e^{k t/\alpha}$,
and show that this satisfies the expectation recurrence for the desired value of $k$.
First, we sum the geometric series:
\[
\mathlarger\sum\limits_{t'=1}^{t-1} \mathbb E[T_{t'}] = \mathlarger\sum\limits_{t'=1}^{t-1} e^{k t'/\alpha}
< \frac{e^{k t/\alpha}-1}{e^{k/\alpha}-1} < \frac{e^{k t/\alpha}}{e^{k/\alpha}-1}
\]
The expectation recurrence to be satisfied then becomes:
\[
\mathbb E[T_t]\le \frac 1{2\alpha}\cdot \frac{e^{k t/\alpha}}{e^{k/\alpha}-1}\cdot \left[ 1+ \frac{\alpha}{\alpha-1} \right]
= e^{k t/\alpha}\cdot \frac{2\alpha-1}{2\alpha(\alpha-1)(e^{k/\alpha}-1)} = e^{k t/\alpha}\cdot f(\alpha, k)
\]
We notice that for $k=1.02$ and $\alpha > 4.5$, $f(\alpha) < 1$.
This can easily be verified by checking that $f(\alpha,1.02)$ decreases monotonically with $\alpha$ in the range $\alpha > 4.5$.
Thus, our recurrence is satisfied for $k=1.02$, and therefore the expected number of calls is $\mathcal O(e^{1.02t/\alpha})$.
\end{proof}

%\begin{corollary}
%\label{cor:coloring_improved_probes}
%Instead of looking through all the epochs in order, we can use the coloring generator \todo{where?} to find the locations directly.
%\end{corollary}

\begin{theorem}
\label{thm:coloring_generator_main}
Given adjacency list query access to a graph with $n$ nodes, maximum degree $\Delta$, and $q=2\alpha\Delta \ge 9\Delta$ colors,
we can sample the color of any given node from a distribution of color assignments that is $\frac{1}{n}$-close (in $L_1$ distance)
to the uniform distribution over all colorings of the graph, in a consistent manner,
using only $\mathcal O(n^{6.12/\alpha}\Delta\log n)$ time and random bits.
%This is sublinear for $\alpha > 6.12$ and the sampled coloring is $1/n$-close to the uniform distribution in $L_1$ distance.
\end{theorem}
\begin{proof}
Since $q\ge 9\Delta$, we can use Corollary~\ref{cor:modified_mixing_time} to obtain $\tau_{mix}(1/n) \le 6\ln n$.
Since $\alpha > 4.5$, we can invoke Lemma~\ref{lem:coloring_recurrence} to conclude that
the number of calls to $\func{Accepted}$ is $\mathcal O(n^{6.12/\alpha})$.
Finally, we note that each call to \func{Accepted}$(v,t)$ potentially samples $\mathcal O(t\Delta)$ color proposals,
while iterating through all the neighbors of $v$ in all $t$ epochs.
Since $t \le 6\ln n$, this implies that the algorithm uses $\mathcal O(n^{6.12/\alpha}\Delta\log n)$ time and random bits,
which is sublinear for $\alpha > 6.12$.
\end{proof}

One final observation is that the value returned (sampled value of $\bm\chi^t_v$) by \func{Accepted} only depends on the sampled values of $C^t_v$,
which in turn depends only on the random bits used by the algorithm.
This implies that unlike the prior implementations, this one does not need to store any state in memory.
Importantly, multiple independent instances of the algorithm that have access to the same random bits,
will invariably answer queries in a manner consistent with each other i.e. they will sample exactly the same coloring.
