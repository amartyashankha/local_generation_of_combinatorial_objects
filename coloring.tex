\section{Random Coloring of a Graph}%
\label{sec:random_coloring_of_a_graph}
A \emph{valid} $q$-coloring of a graph $G=(V, E)$ is a vector of colors $\vec X \in [q]^V$, such that for all $(u,v)\in E$, $\vec X_u \not= \vec X_v$.
We present a sub-linear time algorithm to provide local access to a uniformly random valid $q$-coloring of an input graph.
Specifically, we implement $\func{Color}(v)$, which returns the color $\vec X_v$ of node $v$, where $\vec X$ is a uniformly random valid coloring.
The implementation can access the input graph $G$ through a sub-linear number of \emph{neighborhood queries}.
A neighborhood query of the form $\func{All-Neighbors}(v)$ returns a list of neighbors of $v$.
The implementation can also access a tape of public random bits $\vec R$.

Moreover, multiple independent instances of $\func{Color}$ that are given access to the same public tape of random bits $\vec R$,
should output color values consistent with a single $\vec X$, regardless of the order and content of the queries received.
Unlike our previous results, the choice of $\vec X$ only depends on $\vec R$,
and the \func{Color} implementations do not need to use any additional memory to maintain consistency.
For a formal description of this model, see Definition~\ref{def:local_access_LCA}.
This model is essentially a generalization of \emph{Local Computation Algorithms} \cite{LCA}.
Given a computation problem with input $x$ and a set of valid outputs $F(x)$,
LCAs provide query access to some $y\in F(x)$ using only a sub-linear number of probes to $x$.
This makes it feasible to consider sub-linear algorithms for problems where the output size is super-linear.
Our model has the additional restriction that the output must be drawn uniformly at random from $F(x)$, rather than just being an arbitrary member.
Since the number of possible outputs ($|F(x)|$) may be exponential, it is not possible to encode all the requisite random bits in sub-linear space.
Therefore, we use a source of public randomness $\vec R$.

\paragraph*{Sequential Algorithm for Random Coloring}
\label{par:sequential_algorithm_for_random_coloring}
We consider graphs with max degree $\Delta$, and $q = \Theta(\Delta)$, since this is the regime where this problem is feasible \cite{glauber_survey}.
In the sequential setting, \cite{glauber_survey} used the technique of path coupling to show that for $q > 2\Delta$,
one can sample an uniformly random coloring by using a simple Markov chain.
The Markov chain proceeds in $T$ steps. The state of the chain at time $t$ is given by $\vec X^t\in [q]^{|V|}$.
Specifically, the color of vertex $v$ at step $t$ is $\vec X^t_v$.
In each step of the Markov process, a vertex and a color are sampled uniformly at random i.e. a pair $(v, c)\thicksim_{\mathcal U} V\times [q]$.
Subsequently, if the recoloring of vertex $v$ with color $c$ does not result in a conflict with $v$'s neighbors,
i.e. $c\not\in \left\{ \vec X^t_u : u\in \Gamma(v)\right\}$, then the vertex is recolored i.e. $\vec X_v^{t+1}\leftarrow c$.
After running this chain for $T = \mathcal{O}(n\log (n/\epsilon))$ steps, the Markov chain is mixed,
implying that the distribution of resulting colors is $\epsilon$ close to the uniform distribution in $L_1$ distance.



\subsection{Modified Glauber Dynamics based on a Distributed Algorithm}%
\label{sec:modified_glauber_dynamics}

Now we define a modified Markov chain as a special case of the \emph{Local Glauber Dynamics} presented in \cite{ghaffari_fischer}.
The modified Markov chain proceeds in epochs.
We denote the initial coloring of the graph by the vector $\vec X^0$ and the state of the coloring after the $k^{th}$ epoch by $\vec X^k$.
In the $k^{th}$ epoch, every node attempts to recolor itself simultaneously in a conservative manner, as described below:
\begin{itemize}
    \item Sample $|V|$ colors $ \langle c_1, c_2,\cdots, c_n \rangle$ from $[q]$, where $c_v$ is the color proposed by vertex $v$.
    \item For each vertex $v$, we set $\vec X^k_v$ to $c_v$, if and only if for all neighbors $w$ of $v$, $\vec X^{k-1}_w\not=c_v$ and $c_w\not=c_v$.
Specifically, a vertex $v$ is recolored if and only if its proposed color $c_v$
does not conflict with any of it's neighbors current colors (at the end of the previous epoch), or their current proposals.
\end{itemize}

This procedure is a special case of the \emph{Local Glauber Dynamics},
which was presented in \cite{ghaffari_fischer} as a distributed algorithm for sampling a random coloring.\footnote{
Note that \cite{ghaffari_fischer} also uses a marking probability $\gamma$,
which indicates the likelihood of any vertex participating in a given round.
For our purposes, it suffices to set $\gamma = 1$.}
In the distributed setting, our epochs correspond to synchronous rounds, where many vertices recolor themselves simultaneously.

In order to bound the mixing time of this Markov chain,
\cite{ghaffari_fischer} uses the standard technique of \emph{path coupling}, introduced in \cite{path_coupling}.
The argument begins by considering two initial states of the Markov Chains, say two colorings $\vec X^0$ and $\vec Y^0$,
that differ at only one vertex.
Formally, we can define the distance between two colorings $d(\vec X,\vec Y)$ as the number of vertices $v$ such that $\vec X_v\not= \vec Y_v$,
which results in the condition $d(\vec X^0, \vec Y^0) = 1$.
A \emph{coupling} is a joint evolution rule for a pair of states $(\vec X^0,\vec Y^0)\rightarrow(\vec X^1,\vec Y^1)$,
such that both of the individual evolutions $(\vec X^0\rightarrow \vec X^1)$ and $(\vec Y^0\rightarrow \vec Y^1)$
have the same transition probabilities as the original Markov Chain.
%Now, we pick a random permutation of the vertices along with uniformly sampled colors:
%\[
%\left\langle (v_1, c_1), (v_2, c_2), \cdots, (v_n, c_n)\right\rangle
%= \left\langle (\pi_1, c_1), (\pi_2, c_2), \cdots, (\pi_n, c_n)\right\rangle
%\]
%Now, for each $(v_i, c_i)$ in order, we update the coloring of $X$ and $Y$ as follows:
%\begin{itemize}
    %\item If the current color of $v_i$ as well as $c_i$ are both in $\{c_X,c_Y\}$,
    %then the $\vec X$ chain picks the color $c_i$ and the $\vec Y$ chain picks the other color.
    %\item Otherwise, both chains pick the same color $c_i$ for the vertex $v_i$.
%\end{itemize}
We can directly use the result from the coupling defined in \cite{ghaffari_fischer}.
\begin{lemma}
\label{lem:ghaffari_fischer_single_epoch_distance}
If $q = 2\alpha\Delta$, then there exists a coupling $(\vec X^0,\vec Y^0)\rightarrow(\vec X^1,\vec Y^1)$, such that if $d(\vec X^0, \vec Y^0) = 1$,
then $\mathbb E[d(\vec X^1,\vec Y^1)] \le 1-\left( 1-\frac1{2\alpha}\right)e^{-3/\alpha} + \frac{1/2\alpha}{1-1/\alpha}$
\end{lemma}
\begin{corollary}
\label{cor:single_epoch_distansce}
If $q \ge 9\Delta$ and $d(\vec X^0, \vec Y^0) = 1$, then $\mathbb E[d(\vec X^1,\vec Y^1)] < \frac1{e^{1/3}}$
\end{corollary}

The \emph{path coupling} lemma from \cite{path_coupling} uses a coupling on adjacent states to bound the mixing time.
\begin{lemma}
\label{lem:path_coupling}
\textbf{(Simplified Path Coupling from \cite{path_coupling})}
If there exists a coupling $(\vec X^0,\vec Y^0)\rightarrow(\vec X^1,\vec Y^1)$ defined for states where $d(\vec X^0, \vec Y^0) = 1$,
such that $\mathbb{E}[d(\vec X^1, \vec Y^1) \mid \vec X^0, \vec Y^0] \le \beta$ (for $\beta < 1$),
then, the mixing time $\tau_{mix}(\epsilon) = \mathcal O(\ln (n\epsilon^{-1})/\ln \beta^{-1})$.
\end{lemma}

\begin{corollary}
\label{cor:modified_mixing_time}
If $q\ge 9\Delta$, then the chain is mixed after $\tau_{mix}(\epsilon) = 3\left( \ln n + \ln(\frac1{\epsilon})\right)$ epochs.
\end{corollary}
%\begin{proof}
%Starting for a maximum distance of $n$, the distance decreases to $1$ after at most $3\ln n$ epochs,
%and it takes a further $3\ln\left( \frac{1}{\epsilon} \right)$ to reduce the distance to $\epsilon$.
%\end{proof}
\subsubsection{Naive Reduction from Distributed Algorithms}
\label{sec:naive_reduction_from_distributed_algorithms}
Using the technique of Parnas and Ron \cite{parnas_ron},
one can modify a distributed algorithm for a graph problem to construct a Local Computation Algorithm for the same problem.
Specifically, given a $k$-round distributed algorithm on a network of max degree $\Delta$,
we can simulate the behaviour and outcome of a single node $v$ by simulating the full algorithm on the $k$-neighborhood of $v$.
The simulation only requires us to probe this $k$-neighborhood, which contains $\mathcal O(\Delta^k)$ nodes.
However, the aforementioned distributed algorithm for Glauber Dynamics used $\mathcal O(\log n)$ rounds,
implying a probe complexity of $\Delta^{\mathcal O(\log n)}$, which is super-linear.
We show how to reduce the probe complexity by appropriately pruning the $k$-neighborhood.



\subsection{Local Coloring Algorithm}%
\label{sec:local_coloring_algortihm}
Given query access to the adjacency matrix of a graph $G$ with maximum degree $\Delta$ and a vertex $v$,
the algorithm has to output the color assigned to $v$ after running $t = \mathcal O(\ln n)$ epochs of \emph{Modified Glauber Dynamics}.
We want to be able to answer such queries in sub-linear time, without simulating the entire Markov Chain.
We will define the number of colors as $q = 2\alpha\Delta$ where $\alpha > 1$.

The proposals at each epoch are a vector of color samples $\vec C^{t} \thicksim_{\mathcal U} [q]^n$,
where $\vec C^t_v$ is the color proposed by $v$ in the $t^{th}$ epoch.
Since each of these $\vec C^t_v$ values are independent uniform samples from $[q]$,
instances of our algorithm will be able to access them in a consistent manner using the public random bits $\vec R$.

We also use $\vec X^t$ to denote the final vector of vertex colors at the end of the $t^{th}$ epoch.
Finally, we define indicator variables $\bm \chi^t_v$ to indicate whether the color $\vec C^t_v$ proposed by vertex $v$
was accepted at the $t^{th}$ epoch: $\bm \chi^t_v = \ONE$ if and only if for all neighbors $w\in \Gamma(v)$,
we satisfy the condition $\vec C^t_v\not= \vec X^{t-1}_w$ and $\vec C^t_v\not= \vec C^t_w$
(i.e. the proposed color does not conflict with any neighboring proposal or any neighbor's color from the preceding epoch).
So, the color of a vertex $v$ after the $t^{th}$ epoch $\vec X^t_v$ is set to be $\vec C^i_v$
where $i\le t$ is the largest index such that $\bm \chi^i_v=1$.
While the proposals $\vec C^t_v$ can simply be read off the public random tape $\vec R$,
it is not clear how we can determine the $\bm \chi^t_v$ values efficiently.
Computing $\vec X^t_v$ is quite simple if we know the values $\bm\chi^i_v$ for all $i\le t$.
So, we focus our attention on the query $\func{Accepted}(v,t)$ that returns $\bm\chi^t_v$.


\subsubsection{Local Access to an Initial Valid Coloring}
\label{sec:local_access_to_an_initial_valid_coloring}
One caveat that we have not addressed is how we should initialize the Markov Chain.
The starting state can be any valid coloring of $G$, but we have to be able to access the initial colors of requisite vertices in sub-linear time.
One option is to simply assume that we have oracle access to an arbitrary valid coloring.
We can also invoke a result from \cite{coloring_initialize} that provides a \emph{Local Computation Algorithm} for $(\Delta+1)$-coloring of a graph.
Specifically, they provide local access to the color of any vertex using $\mathcal O(\Delta^{\mathcal O(1)}\log n)$ queries to the underlying graph,
such that the returned colors are consistent with some valid coloring.
Integrating their routine into our algorithm incurs a multiplicative $\poly(\Delta)$ overhead for each query.

Another option is to (uniformly) randomly intialize the colors of the vertex independently of its neighbors.
Although the initial coloring may be invalid, one can show that with high probability, the final coloring after running the Markov Chain is valid.
The intuitive reasoning is that each vertex attempts to recolor itself $\mathcal O(\log n)$ times,
and each attempt suceeds with constant probabiltity at least $1 - 1/\alpha$ (Lemma~\ref{lem:color_reject_probability}).
Furthermore, we can union bound to claim that \emph{all} the vertices get re-colored at least once with high probability.
After a vertex is re-colored once, it can no longer be in conflict with any of its neighbor's colors,
and therefore we obtain a final coloring that is valid.
For the sake of simplicity, we will assume that our algorithm can access the initial colors of any vertex $v$ through a public $\vec C^0_v$.

\subsubsection{Naive Coloring Implementations}%
\label{sec:naive_coloring_implementations}
Our general strategy to determine $\bm\chi^t_v$ will be to check for all neighbors $w$ of $v$,
whether $w$ causes a conflict with $v$'s proposed color in the $t^{th}$ epoch.
One naive way to achieve this, is to iterate backwards from epoch $t$, querying to find out whether $w$'s proposal was accepted,
until the most recent accepted proposal (latest epoch $t' < t$ such that $\bm\chi^{t'}_w=\ONE$) is found.
At this point, if $\vec C^{t'}_w =\vec C^t_v$, then the current color of $w$ conflicts with $v$'s proposal.
Otherwise there is no conflict, and we can proceed to the next neighbor.
However, this process potentially makes $\Delta$ recursive calls to a sub-problem that is only slightly smaller i.e. $T(t) \le \Delta\cdot T(t-1)$.
This leads to a running time upper bound of $\Delta^{t}$ which is superlinear for the desired number of epochs $t = \Omega(\log n)$ (the mixing time).

We can prune the number of recursive calls by only processing the neighbors $w$ which actually proposed the color $\vec C^t_v$ during \emph{some} epoch.
In this case, the expected number of neighbors that have to be probed recursively is less than $t\Delta/q$
(since the total number of neighbor proposals over $t$ epochs is at most $t\Delta$, and there are $q$ possible colors).
So, the overall runtime is upper bounded by $(t\Delta/q)^{t}$.
For this algorithm, if we allow $q > t\Delta = \Omega(\Delta\log n)$ colors, the runtime becomes sub-linear.
So, we can use this simple algorithm only when $q$ is sufficiently large.
However, we want a sub-linear time algorithm for $q = \mathcal O(\Delta)$.


\subsubsection{A Sub-linear Time Algorithm for $q = \mathcal O(\Delta)$} \todo{Go over this again}
\label{sec:jumping_back_to_past_epochs}
The expected number of neighbors that need to be checked recursively can always be $t\Delta/q$ in the worst case.
The crucial observation is that even though these recursive calls seem unavoidable,
we can aim to reduce the size of the recursive sub-problem, and thus bound the number of levels of recursion.

Algorithm~\ref{alg:coloring} shows our final procedure for generating $\bm\chi^t_v$, where $c =\vec C^t_v$ is $v$'s proposal at epoch $t$.
We iterate through all neighbors $w$ of $v$, checking for conflicts.
The condition $c\not=\vec C^t_w$ can be checked by reading $\vec C^t_w$ off the public random tape.
If no conflict is seen, we proceed to check whether $c\not= \vec X^{t-1}_w$.

\begin{figure}[htpb]
\begin{framed}
    \renewcommand\figurename{Algorithm}
    \caption{Checking if proposal is accepted}
    \label{alg:coloring}
    \begin{algorithmic}[1]
        \Procedure{Accepted}{$v, t$}
            \State {$c\gets\vec C^t_v$} \Comment{\parbox[t]{.57\linewidth}{Find the current proposal using the public random bits}}
            \For{$w \gets \Gamma(v)$} \Comment{\parbox[t]{.57\linewidth}{Iterate through the neighbors, checking for conflicts}}
                \If {$\vec C_w^t = c$} \Comment{\parbox[t]{.57\linewidth}{Check for conflict with neighbor's current proposal}}
                    \State \Return $\ZERO$
                \EndIf
                \For{$t' \gets [t, t-1, t-2, \cdots, 1, 0]$} \label{alg:line:iterate_backwards}
                \Comment{\parbox[t]{.5\linewidth}{Check for conflict with neighbor's prior state}}
                    \If {$\mathcal\vec C^{t'}_w = c$ \textbf{and} \func{Accepted}($w, t'$)} \label{alg:line:check_accepted}
                        \Comment{\parbox[t]{.5\linewidth}{Potential conflict with neighbor's color}}
                        \State $overwritten\gets \FALSE$ \Comment{\parbox[t]{.5\linewidth}{Check if color $c$ is overwritten by a future proposal}}
                        \For{$\widetilde t \gets {\scriptstyle [t'+1, t'+2, t'+3, \cdots, t-1]}$} \label{alg:line:check_overwritten}
                            \If {\func{Accepted}($w, \widetilde t$)} \label{alg:line:check_overwritten_recursive}
                                \State $overwritten\gets \TRUE$
                                \State \textbf{break}
                            \EndIf
                        \EndFor
                        \If {\textbf{not} $overwritten$}
                        \State \Return $\ZERO$
                        \Comment{\parbox[t]{.6\linewidth}{Conflict! This proposal is \textbf{not} accepted} \label{alg:line:conflict}}
                        \EndIf
                        \State \textbf{break}
                   \EndIf
                \EndFor
            \EndFor
            \State \Return $\ONE$ \Comment{\parbox[t]{.6\linewidth}{No conflicts! This proposal is accepted} \label{alg:line:no_conflict}}
        \EndProcedure
    \end{algorithmic}
\end{framed}
\end{figure}
To achieve this, we iterate through all the epochs in reverse order (line~\ref{alg:line:iterate_backwards})
to check whether the color $c$ was ever proposed for vertex $w$.
If not, we can ignore $w$.
Otherwise let's say that the most recent proposal for $c$ was at epoch $t'$ i.e. $\vec C^{t'}_w = c$.
Now, we directly ``jump'' to the $(t')^{th}$ epoch and recursively check if this proposal was accepted (line~\ref{alg:line:check_accepted}).
If the proposal $\vec C^{t'}_w$ was not accepted, we keep iterating back in time until we find the next most recent epoch
when $c$ was proposed by $w$, or until we run out of epochs.
When we find the most recent epoch $t'$ in which $c$ was accepted i.e. $\bm\chi^{t'}_w = \ONE$,
we successively consider epochs $t'+1, t'+2, t'+3, \cdots, t-1$ to see whether the color $c$ was overwritten
(line~\ref{alg:line:check_overwritten}) by an accepted proposal in a future epoch.
This is done by recursively invoking $\func{Accepted}(w,t'+i)$ in order to compute $\bm\chi^{t'+i}_w$ (line~\ref{alg:line:check_overwritten_recursive}).
If at any of these subsequent iterations, we see that a different proposal was accepted (thus overwriting the color $c$),
then neighbor $w$ does not cause a conflict, and we can move on to the next neighbor.
Otherwise, we have seen that $\bm\chi^{t'}_w = \ONE$ (color $c$ was accepted) and every subsequent proposal until the current epoch $t$ was rejected,
implying that color $c$ \emph{survived} as the color of neighbor $w$, i.e. $\vec X^{t-1}_w = c$.
This leads to a conflict with $v$'s current proposal for color $c$ (line~\ref{alg:line:conflict}) and hence $\bm\chi^t_v = \ZERO$.
If we exhaust all the neighbors and don't find any conflicts (line~\ref{alg:line:no_conflict}) then $\bm\chi^t_v = \ONE$.

Now we analyze the runtime of $\func{Accepted}$ by constructing and solving a recurrence relation.
We will use the following lemma to evaluate the expectation of products of relevant random variables.

\begin{lemma}
\label{lem:color_reject_probability}
The probability that any given proposal is rejected $\mathbb P[\bm\chi^t_v=\ZERO]$ is at most $1/\alpha$.
Moreover, this upper bound holds even if we condition on all the values in $\vec C$ except $\vec C^t_v$.
\end{lemma}
\begin{proof}
A rejection can occur due to a conflict with at most $2\Delta$ possible values in $\{\vec C^t_w, \vec X^{t-1}_w | w\in\Gamma(v)\}$.
Since there are $2\alpha\Delta$ colors, the rejection probability is at most $1/\alpha$.
\end{proof}

\begin{definition}
\label{def:coloring_recursions}
We define $T_t$ to be a random variable indicating the number of recursive calls performed during the execution of $\func{Accepted}(v,t)$
while computing a single $\bm \chi_v^t$.
\end{definition}

\begin{definition}
\label{def:blah}
We define $W^t_{t'}$ to be a random variable indicating the number of calls to \func{Accepted} that are required,
to check whether a color $c$ assigned at epoch $t'$ was overwritten at some epoch before $t$.
\end{definition}
Using $\mathcal B(p)$ to denote the Bernoulli random variable with bias $p$, we obtain an expression for $R^t_{t'}$.
\begin{align}
\label{eq:color_overwrite}
W^t_{t'} \le \Biggl[T_{t'+1} + \mathcal B\left(\frac{1}{\alpha}\right)\cdot T_{t'+2}
+ \mathcal B\left(\frac{1}{\alpha^2}\right)\cdot T_{t'+3} + \cdots
+ \mathcal B\left(\frac{1}{\alpha^{t-t'-2}}\right)\cdot T_{t-1} \Biggr]
\end{align}
The above Equation~\ref{eq:color_overwrite} conservatively assumes that the call to $\func{Accepted}(v, t'+1)$
in line~\ref{alg:line:check_overwritten_recursive} is always invoked (resulting in $T_{t'+1}$ invocations of \func{Accepted}).
However, the next call to $\func{Accepted}(v, t'+2)$ occurs only if the previous one was not accepted,
which happens with probability $\le 1/\alpha$ (Lemma~\ref{lem:color_reject_probability}).
This produces the $\mathcal B(1/\alpha)\cdot T_{t'+2}$ term in the expression.
In general, $\func{Accepted}(v, t'+i)$ is only invoked if the preceding $i-1$ calls to \func{Accepted} all returned $\ZERO$.
This event happens with probability at most $1/\alpha^{i-1}$.

Next, we prove our main lemma that bounds the number of recursive calls to \func{Accepted}.

\begin{lemma}
\label{lem:coloring_recurrence}
Given graph $G$ and $q=2\alpha\Delta$ colors, for $\alpha > 4.5$, the expected number of recursive calls to the procedure $\func{Accepted}$
while computing a single $\bm\chi^t_v = \func{Accepted}(v,t)$ is $\mathbb E[T_t] = \mathcal{O}\left(e^{1.02t/\alpha}\right)$.
\end{lemma}
\begin{proof}
We start by constructing a recurrence for the expected number of calls to $\func{Accepted}$ used by the algorithm.
When checking a single neighbor $w$, the algorithm iterates through all the epochs $t'$ such that $\vec C^{t'}_w = c$
(in reality, only the last occurence matters, but we are looking for an upper bound).
If such a $t'$ is found (this happens with probability $1/q$ independently for each trial), there is a recursive call to $\func{Accepted}(w,t')$,
which in turn results in $T_{t'}$ recursive calls to \func{Accepted}.
If we find that $\bm\chi^{t'}_w = \ONE$ (i.e. $w$ was colored to $c$ at epoch $t'$),
we will need to proceed to check whether the color was subsequently overwritten, which requires an additional $W^t_{t'}$ calls to \func{Accepted}.
%Adding an extra $T_{t'}$ term (corresponding to $\func{Accepted}(w,t')$) to Equation~\ref{eq:color_overwrite},
%and summing up over all neighbors and epochs, we obtain the following:
Summing up over all neighbors and epochs, we obtain the following bound:
\begin{align}
T_{t} &= \textcolor{Fuchsia}{\mathlarger\sum\limits_{w\in \Gamma(v)}}\ \
\mathlarger\sum\limits_{t'=1}^{t}\ \  \textcolor{Blue}{\mathbb P\left[\vec C^{t'}_w = c\right]}\cdot
\left[ \textcolor{BrickRed}{T_{t'}} + \textcolor{OliveGreen!80!black}{W^t_{t'}} \right] \\
&\le \textcolor{Fuchsia}{\Delta} \cdot \mathlarger\sum\limits_{t'=1}^{t} \textcolor{Blue}{\mathcal B\left( \frac 1q\right)}\cdot
\left[ \textcolor{BrickRed}{T_{t'}} +
\textcolor{OliveGreen!80!black}{T_{t'+1} + \mathcal B\left(\frac{1}{\alpha}\right)\cdot T_{t'+2} +
\mathcal B\left(\frac{1}{\alpha^2}\right)\cdot T_{t'+3}
+ \cdots + \mathcal B\left(\frac{1}{\alpha^{t-t'-2}}\right)\cdot T_{t-1}} \right]\\
&\le \textcolor{Fuchsia}{\Delta} \cdot \textcolor{Blue}{\mathcal B\left( \frac{1}{q}\right)} \cdot \Biggl[
\textcolor{BrickRed}{\mathlarger\sum\limits_{t'=1}^{t-1} T_{t'}} +
\textcolor{OliveGreen!80!black}{\mathlarger\sum\limits_{t'=1}^{t-1} T_{t'}\cdot
\left(1 + \mathcal B\left(\frac1\alpha\right) + \mathcal B\left(\frac1{\alpha^2}\right) + \cdots\right)}
\Biggr]
\end{align}
In the last step, we just grouped together all the terms corresponding to the same epoch
(note that we include additional terms since it's an upper bound).
Using Lemma~\ref{lem:color_reject_probability} and the fact that $\textcolor{Blue}{\mathbb P[\vec C^{t'}_w = c]}$ is independent of all other events,
we can write a recurrence for the expected number of probes.
\begin{align}
\mathbb E[T_t] \le \textcolor{Fuchsia}{\Delta} \cdot \textcolor{Blue}{\frac{1}{2\alpha\Delta}}
\left[
\textcolor{BrickRed}{\mathlarger\sum\limits_{t'=1}^{t-1} T_{t'}} +
\textcolor{OliveGreen!80!black}{\mathlarger\sum\limits_{t'=1}^{t-1} T_{t'}\cdot \left(1 + \frac1\alpha + \frac1{\alpha^2} + \cdots\right)}
\right]
\le \frac{1}{2\alpha}\cdot \mathlarger\sum\limits_{t'=1}^{t-1} T_{t'}\cdot \left[1 + \frac{\alpha}{\alpha-1} \right]
\end{align}
Now, we make the assumption that $\mathbb E[T_{t'}]\le e^{k t/\alpha}$,
and show that this satisfies the expectation recurrence for the desired value of $k$.
First, we sum the geometric series:
\[
\mathlarger\sum\limits_{t'=1}^{t-1} \mathbb E[T_{t'}] = \mathlarger\sum\limits_{t'=1}^{t-1} e^{k t'/\alpha}
< \frac{e^{k t/\alpha}-1}{e^{k/\alpha}-1} < \frac{e^{k t/\alpha}}{e^{k/\alpha}-1}
\]
The expectation recurrence to be satisfied then becomes:
\[
\mathbb E[T_t]\le \frac 1{2\alpha}\cdot \frac{e^{k t/\alpha}}{e^{k/\alpha}-1}\cdot \left[ 1+ \frac{\alpha}{\alpha-1} \right]
= e^{k t/\alpha}\cdot \frac{2\alpha-1}{2\alpha(\alpha-1)(e^{k/\alpha}-1)} = e^{k t/\alpha}\cdot f(\alpha, k)
\]
We notice that for $k=1.02$ and $\alpha > 4.5$, $f(\alpha) < 1$.
This can easily be verified by checking that $f(\alpha,1.02)$ decreases monotonically with $\alpha$ in the range $\alpha > 4.5$.
Thus, our recurrence is satisfied for $k=1.02$, and therefore the expected number of calls is $\mathcal O(e^{1.02t/\alpha})$.
\end{proof}

\ColoringGrand*
\begin{proof}
Since $q\ge 9\Delta$, we can use Corollary~\ref{cor:modified_mixing_time} to obtain $\tau_{mix}(\epsilon) \le 3(\ln n + \ln 1/\epsilon)$.
Also, since $\alpha > 4.5$, we can invoke Lemma~\ref{lem:coloring_recurrence} to conclude that
the number of calls to $\func{Accepted}$ is $\mathcal O(n^{3.06/\alpha}\epsilon^{-3.06/\alpha})$.
Finally, we note that each call to \func{Accepted}$(v,t)$ potentially reads $\mathcal O(t\Delta)$ color proposals from the public random tape,
while iterating through all $\le \Delta$ neighbors of $v$ in all $t$ epochs.
Since $t \le 3\ln (n/\epsilon)$, this implies that the algorithm uses
$\mathcal O((n/\epsilon)^{3.06/\alpha}\Delta\log (n/\epsilon))$ time and random bits, which is sub-linear for $\alpha > 3.06$.
\end{proof}
