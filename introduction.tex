\section{Introduction}
The problem of computing local information of huge random objects was pioneered in \cite{huge_old,huge}.
Further work of \cite{sparse} considers the generation of sparse random $G(n,p)$ graphs from the Erd\"{o}s-R\'{e}nyi model \cite{er},
with $p = O(\poly(\log n)/n)$, which answers $\poly(\log n)$ \func{All-Neighbors} queries, listing the neighbors of queried vertices.
While these generators use polylogarithmic resources over their entire execution,
they generate graphs that are  only guaranteed to {\em appear random} to algorithms that inspect a {\em limited portion} of the generated graph.
For example, the greedy routing algorithm on Kleinberg's small world networks \cite{kleinberg} only uses $\mathcal O(\log^2 n)$ probes.
Using our implementation, one can execute this algorithm on a random small world instance
in $\mathcal O(\poly(\log n))$ time without incurring the $\mathcal O(n)$ prior-sampling overhead.

In \cite{reut}, the authors construct an oracle for the generation of recursive trees, and BA preferential attachment graphs.
Unlike \cite{sparse}, their implementation allows for an arbitrary number of queries.
This result is particularly interesting --  although the graphs in this model are generated via a sequential process,
the oracle is able to locally generate arbitrary portions of it and answer queries in polylogarithmic time.
Though preferential attachment graphs are sparse, they contain vertices of high degree,
thus \cite{reut} provides access to the adjacency list through \func{Next-Neighbor} queries.
\todo{Segway}


\todo[inline,color=Red!20]{Section on undirected graphs.}

\subsection{Directed Graphs}
\label{sec:directed_graphs}
We then consider local-access generators for directed graphs in Kleinberg's Small World model.
In this case, the probabilities are based on distances in a 2-dimensional grid.
Using a modified version of our previous sampling procedure, we present such a generator supporting \func{All-Neighbors} queries in
$\mathcal{O}(\poly(\log n))$ time, space and random bits per query (since such graphs are sparse, the other queries follow directly).
\todo{This is duplicate}

Lastly, we consider Kleinberg's Small World model (\cite{kleinberg, klein}) in Section~\ref{sec:small_world}.
While Small-World models are proposed to capture 
properties of observed data such as small shortest-path 
distances and large clustering coefficients \cite{watts1998collective}, 
this important special case of Kleinberg's model, defined on two-dimensional grids, 
demonstrates underlying geographical structures of networks. 
The vertices are aligned on a $\sqrt{n}\times\sqrt{n}$ grid,
and the edge probabilities are a function of a two-dimensional distance metric.
Since the degree of each vertex in this model is $\Bo(\log n)$ with high probability,
we design generators supporting \func{All-Neighbor} queries.
%In contrast to our previous cases, this model imposes an underlying
%two-dimensional structure of the vertex set, which governs
%the distance function as well as complicates the individual edge probabilities.




\subsection{Catalan Objects}%
\label{sec:catalan_objects}
We also consider the problem of sampling of very long ($2n$ step) one dimensional random walks,
One obvious query of interest is $\func{Height}(t)$ which returns the position of the walk at time $t$.
\func{Height} queries for the simple unconstrained random walk
follow trivially from the implementation of interval summable functions presented in \cite{huge}.
Instead, we focus on an important generalization by considering balanced random walks (equal number of up and down steps)
that are constrained to be always positive (commonly known as Dyck Paths).
The added constraint introduces complicated non-local dependencies on the distribution of positions.
However, we are able to support both queries using $\mathcal O(\poly(\log n))$ resources.

Dyck paths are one type of Catalan object, and they have natural bijections to other Catalan objects
such as bracketed expressions, random rooted trees and binary trees
Thus, we can use our Dyck Path implementation to obtain useful implementations of other random Catalan objects.
For instance, $\func{Height}$ queries correspond to $\func{Depth}$ queries on rooted trees and bracketed expressions
(Section~\ref{sec:bijections_to_other_catalan_objects}).

\todo{Why are first returns difficult?}
\todo{Dependencies from past queries}
However, we might want to support more interesting qaueries; for example,
finding the children of a node in a random tree or finding the matching bracket in a random bracketed expression.
To achieve this, we will also support \func{First-Return} queries
where $\func{First-Return}(t)$ returns the first time when the random walk returns to the same level as it was at time $t$.
In Section~\ref{sec:bijections_to_other_catalan_objects}, we will see that $\func{First-Return}$ queries correspond to
$\func{Next-Neighbor}$ queries on trees and $\func{Matching-Bracket}$ queries on bracketed expressions.





\subsection{Random Coloring of Graphs}%
\label{sec:random_coloring_of_graphs}
Finally, we introduce a new model for implementating huge random objects with \emph{huge description size}.
In this model, we implement query access to random $q$-colorings of arbitrary graphs with maximum degree $\Delta$.
A random coloring is sampled by proposing $\mathcal O(n\log n)$ color updates and accepting the ones that do not create a conflict (Glauber dynamics).
This is an inherently sequential process with the acceptance of a particular proposal depending on all preceding neighboring proposals.
Moreover, unlike the previously considered random objects, this one has no succint representation,
and we can only uncover the proper distribution by probing the graph (in the manner of \emph{local computation algorithms} \cite{LCA}).
Unlike LCAs which have to return \emph{some} valid solution, we also have to make sure that we return a solution from the correct distribution.
We are able to construct an efficient implementation that returns the final color of a vertex using only a sub-linear number of probes when $q>12\Delta$.

For additional related work, see Section~\ref{sec:related_work}.
