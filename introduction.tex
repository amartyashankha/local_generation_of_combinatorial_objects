\section{Introduction}
Consider an algorithm performing a computation on a \emph{huge random object} (for example a random graph or a ``long'' random walk).
Is it necessary to generate the entire object prior to the computation,
or is it possible to provide query access to the object and sample it incrementally ``on-the-fly'' (as requested by the algorithm)?
Such an \emph{implementation} would emulate the random object by answering appropriate queries in a consistent manner.
Specifically, all responses to queries must be consistent with an instance of the random object sampled from the true distribution (or close to it).
This paradigm is useful when the algorithm is sub-linear and thus,
requiring the algorithm to sample the entire object up front would ruin its efficiency.
The problem of sampling partial information about huge random objects was pioneered in \cite{huge_old,huge}.
Further work in \cite{sparse,reut} considers the generation of different random graph models.




\subsection{Random Graphs}%
\label{sec:random_graphs}
In Section~\ref{sec:undirected}, we implement queries to both the adjacency matrix and adjacency list representation
for the generic class of \emph{undirected graphs} with {\em independent edge probabilities} $\left\{ p_{uv} \right\}_{u,v\in V}$,
where $p_{uv}$ denotes the probability that there is an edge between $u$ and $v$.
Throughout, we identify our vertices via their unique IDs from $1$ to $n$, namely $V = [n]$.
We implement \func{Vertex-Pair}, \func{Next-Neighbor}, and \func{Random-Neighbor}
\footnote{\func{Vertex-Pair}$(u,v)$ returns whether $u$ and $v$ are adjacent, \func{Next-Neighbor}$(v)$ returns a new neighbor of $v$ each time
it is invoked (until none is left), and \func{Random-Neighbor}$(v)$ returns a uniform random neighbor of $v$ (if $v$ is not isolated).} queries.
Under reasonable assumptions on the ability to compute certain values pertaining to consecutive edge probabilities,
our implementations support all three types of queries using $\mathcal{O}(\poly(\log n))$ time, space, and random bits.
In particular, our construction yields local-access implementations for the Erd\"{o}s-R\'{e}nyi $G(n,p)$ model (for \emph{all} values of $p$),
and the Stochastic Block model with random community assignment.
As in \cite{reut} (and unlike the implementations in \cite{huge_old,huge,sparse}), our techniques allow unlimited queries.

While \func{Vertex-Pair} and \func{Next-Neighbor} queries, as well as \func{All-Neighbors} queries for sparse graphs,
have been considered in the prior works of \cite{reut, huge_old, huge, sparse}, we provide the first implementation (to the best of our knowledge)
of \func{Random-Neighbor} queries, which do not follow trivially from the \func{All-Neighbor} queries in \emph{non-sparse graphs}.
Such queries are useful, for instance, for sub-linear algorithms that employ random walk processes.
\func{Random-Neighbor} queries present particularly interesting challenges that are outlined below.


\paragraph*{Directed Random Graphs: The Small World Model}
\label{par:directed_random_graphs}
We then consider local-access implementations for directed graphs in Kleinberg's Small World model.
In this case, the probabilities are based on distances in a 2-dimensional grid.
Using a modified version of our previous sampling procedure, we implement \func{All-Neighbors} queries using
$\mathcal{O}(\poly(\log n))$ time, space and random bits (since such graphs are sparse, the other queries follow directly).




\subsection{Catalan Objects}%
\label{sec:intro_catalan_objects}
We also consider the problem of sampling of very long ($2n$ step) one dimensional random walks,
One obvious query of interest is $\func{Height}(t)$ which returns the position of the walk at time $t$.
\func{Height} queries for the simple unconstrained random walk
follow trivially from the implementation of interval summable functions presented in \cite{huge}.
Instead, we focus on an important generalization by considering balanced random walks (equal number of up and down steps)
that are constrained to be always positive (commonly known as Dyck Paths).
The added constraint introduces complicated non-local dependencies on the distribution of positions.
However, we are able to support both queries using $\mathcal O(\poly(\log n))$ resources.

Dyck paths are one type of Catalan object, and they have natural bijections to other Catalan objects
such as bracketed expressions, random rooted trees and binary trees
Thus, we can use our Dyck Path implementation to obtain useful implementations of other random Catalan objects.
For instance, $\func{Height}$ queries correspond to $\func{Depth}$ queries on rooted trees and bracketed expressions
(Section~\ref{sec:bijections_to_other_catalan_objects}).

\todo{Why are first returns difficult?}
\todo{Dependencies from past queries}
However, we might want to support more interesting queries; for example,
finding the children of a node in a random tree or finding the matching bracket in a random bracketed expression.
To achieve this, we will also support \func{First-Return} queries
where $\func{First-Return}(t)$ returns the first time when the random walk returns to the same level as it was at time $t$.
In Section~\ref{sec:bijections_to_other_catalan_objects}, we will see that $\func{First-Return}$ queries correspond to
$\func{Next-Neighbor}$ queries on trees and $\func{Matching-Bracket}$ queries on bracketed expressions.





\subsection{Random Coloring of Graphs}%
\label{sec:random_coloring_of_graphs}
Finally, we introduce a new model for implementating huge random objects with \emph{huge description size};
that is, the distribution is specified as a uniformly random solution to a huge combinatorial problem.
In this model, we implement query access to random $q$-colorings of a given huge graph $G$ with maximum degree $\Delta$.
A random coloring is sampled by proposing $\mathcal O(n\log n)$ color updates and accepting the ones that do not create a conflict (Glauber dynamics).
This is an inherently sequential process with the acceptance of a particular proposal depending on all preceding neighboring proposals.
Moreover, unlike the previously considered random objects, this one has no succinct representation,
and we can only uncover the proper distribution by probing the graph (in the manner of \emph{local computation algorithms} \cite{LCA}).
Unlike LCAs which have to return \emph{some} valid solution, we also have to make sure that we return a solution from the correct distribution.
We are able to construct an efficient oracle that returns the final color of a vertex using only a sub-linear number of probes when $q\ge 7\Delta$.

For additional related work, see Section~\ref{sec:related_work}.
