\begin{abstract}

Consider an algorithm performing a computation on a \em{huge random object} (for example a random graph or a ``long'' random walk).
Is it necessary to generate the entire object prior to the computation,
or is it possible to provide query access to the object and sample it incrementally ``on-the-fly'' (as requested by the algorithm)?
Such an \emph{implementation} would emulate the random object by answering appropriate queries in a consistent manner.
Specifically, all responses to queries must be consistent with an instance of the random object sampled from the true distribution (or close to it).
This paradigm is useful when the algorithm is sub-linear and thus,
requiring the algo to sample the entir obj up front would ruin its efficieny.

Our first set of results focus on undirected graphs with independent edge probabilities,
that is, each edge is chosen as an independent Bernoulli random variable.
We provide a general implementation for generators in this model.
Then, we use this construction to obtain the first efficient local implementations for the Erd\"{o}s-R\'{e}nyi $G(n,p)$ model,
and the Stochastic Block model.
As in previous local-access implementations for random graphs,
we support \func{Vertex-Pair}, \func{Next-Neighbor} queries, and \func{All-Neighbors} queries.
In addition, we introduce a new \func{Random-Neighbor} query.
We also give the first local-access generation procedure for \func{All-Neighbors} queries in the (sparse and directed) Kleinberg's Small-World model.
\textcolor{red}{ Note that, in the sparse case, an \func{All-Neighbors} query can be used to simulate the other types of queries efficiently.}
All of our generators require no pre-processing time, and answer each query using $ \mathcal{O}(\poly(\log n)) $ time, random bits, and additional space.

We next show how to implement random Catalan objects, specifically focusing on Dyck paths (balanced random walks that are always positive).
Here, we support $\func{Height}$ queries to find the location of the walk,
and $\func{First-Return}$ queries to find the time when the walk returns to a specified location.
This generator can be used to implement $\func{Next-Neighbor}$ queries on random rooted and binary trees,
and $\func{Matching-Bracket}$ queries on random well bracketed expressions (the Dyck language).

Finally, we study random $q$-colorings of graphs with maximum degree $\Delta$.
This is a new setting where the random object also has a ``huge'' description (the underlying graph) that can be accessed through adjacency list queries.
This setting is similar to Local Computation Algorithms \cite{LCA, LCA_space_efficient}
with the added restriction that the output must follow a specific distribution in addition to being legal.
We show how to sample the color of a single node in sub-linear time when $q > \alpha\Delta$ where $\alpha$ is a small constant.

%rr Such an oracle for local access to the random
%graph can be useful when one only needs to query a small portion
%Local access is extensively used in sub-linear time algorithms and local algorithms,
%where the algorithms inspect the input graph by interacting with the oracle:
%optimizing the time per query (without any preprocessing overhead)
%would lead to more efficient implementations over random graphs.

%rr We give the first local-access procedures that 
%Our construction provides the first local-access generators for the
%Erd\"{o}s-R\'{e}nyi model ($G(n,p)$) and the Stochastic Block model,
%and also the first generators for \emph{dense graphs}.
%We support all three query types.
%\textcolor{red}{
%Note that in sparse graphs, an \func{All-Neighbors} query provides all three.
%}

\end{abstract}

\newpage
