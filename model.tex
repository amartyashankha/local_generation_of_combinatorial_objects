\subsection{Local-Access Generators}
We begin by formalizing a model of \emph{local-access implementations} (Section~\ref{sec:oracle_model}), implicitly used in \cite{reut}.
\todo{Not good}
Our work provides local-access generators for various basic classes of graphs described in the following, with 
\func{Vertex-Pair}, \func{Next-Neighbor}, and \func{Random-Neighbor} queries.
In all of our results, each query is processed using $\poly(\log n)$ time, random bits, and additional space, with \emph{no initialization overhead}.
These guarantees hold even in the case of adversarial queries.
Our bounds assume constant computation time for each arithmetic operation with $O(\log n)$-bit precision.
Each of our generators constructs a random graph drawn from a distribution that is $1/\poly(n)$-close to the desired distribution in the $L_1$-distance.
\footnote{The \emph{$L_1$-distance} between two probability distributions $\mathsf{p}$ and $\mathsf{q}$ over domain $D$
is defined as $\|\mathsf{p-q}\|_1 = \sum_{x \in D } |p(x)-q(x)|$.
We say that $\mathsf{p}$ and $\mathsf{q}$ are $\epsilon$-close if $\|\mathsf{p-q}\|_1 \leq \epsilon$.}

Inspired by the goals and results of \cite{reut}, we define a model of local-access generators as follows.

\begin{definition}
\label{def:local_access}
Given a distribution $X$ over a set of huge random objects $\mathbb X$, a \emph{local access implementation}
of a family of query functions $\langle F_1, F_2,\cdots \rangle$ where $F_i: \mathbb X\rightarrow \{0,1\}$,
provides an oracle that returns the value $F_i(X)$ for $X\thicksim \mathbb X$ and a given query $F_i$, while satisfying the following:
%For clarity, we assume that the generator is invoked until its entire graph $G$ is exposed.
%The local-access generator for a probability distribution $\mathsf{D}$ of the desired random graph model must satisfy the following properties:
\begin{itemize}
    \item \textbf{Consistency:}
    All the values $F_i(X)$ returned by the local-access implementation throughout the entire execution
    must be consistent with a single $X\in \mathbb X$.
    \item \textbf{Distribution equivalence:}
    The random object $X\in \mathbb X$ consistent with the responses $\{ F_i(X)\}$ must be sampled from some distribution $\mathsf{X}'$
    that is $\epsilon$-close to the desired distribution $\mathsf{X}$ in $L_1$-distance.
    In this work we focus on supporting $\epsilon = n^{-c}$ for any desired constant $c>0$.
    \item \textbf{Performance:}
    The computation time, additional random bits, and additional space required to answer a single query must be sub-linear,
    and preferably $\poly(\log n)$ with high probability.
\end{itemize}
\end{definition}
In particular, we allow queries to be made adversarially and non-deterministically. The adversary has full knowledge of the generator's behavior and its past random bits.





\subsection{Basic Tools for Efficient Sampling}
\label{sec:basic_tools_for_efficient_sampling}
\begin{lemma}
\label{lem:rejection_sampling}
Let $\{p_i\}$ and $\{q_i\}$ be distributions satisfying the following conditions
\begin{enumerate}
    \item There is a poly-time algorithm to approximate $p_i$ and $q_i$ up to $\pm n^{-2}$
    \item Generating an index $i$ according to $q_i$ is closely implementable.
    \item There exists a $poly(log n)$-time recognizable set $B$ such that
    \begin{itemize}
        \item $1-\sum\limits_{i\in B} p_i$ is negligible
        \item There exists a constant $c$ such that for every $i$, it holds that $p_i\le \log^{\mathcal{O}(1)} n\cdot q_i$
    \end{itemize}
\end{enumerate}
Then, generating an index $i$ according to the distribution $\{p_i\}$ is closely-implementable.
\end{lemma}

\paragraph*{CDF Based Sampling}
\label{par:cdf_based_sampling}

Consider a probability distribution $\mathsf{X}$ over $O(n)$ consecutive integers,
whose cumulative distribution function (CDF) for can be computed with at most $n^{-c}$ additive error for constant $c$.
Using $\Bo(\log n)$ CDF evaluations, one can sample from a distribution that is $\frac{1}{\poly(n)}$-close to $\mathsf{X}$ in $L_1$-distance.
\footnote{Generate a random $N$-bit number $r$, and binary-search for the smallest domain element $x$ where $\mathbb P[X\leq x] \geq r$.}
